/*
MultiBaas API

MultiBaas's REST APIv0.

API version: 0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package multibaas

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type ContractsAPI interface {

	/*
		CallContractFunction Call a contract function

		Builds a transaction to call the given contract function. Returns a transaction to be signed and signs and submits to the blockchain it if the `signAndSubmit` flag is enabled.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param chain The blockchain chain label.
		@param addressOrLabel An address or the label of an address.
		@param contract
		@param method Contract function.
		@return ApiCallContractFunctionRequest
	*/
	CallContractFunction(ctx context.Context, chain ChainName, addressOrLabel string, contract string, method string) ApiCallContractFunctionRequest

	// CallContractFunctionExecute executes the request
	//  @return CallContractFunction200Response
	CallContractFunctionExecute(r ApiCallContractFunctionRequest) (*CallContractFunction200Response, *http.Response, error)

	/*
		CreateContract Create a contract

		Adds a contract.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param contract
		@return ApiCreateContractRequest
	*/
	CreateContract(ctx context.Context, contract string) ApiCreateContractRequest

	// CreateContractExecute executes the request
	//  @return GetContract200Response
	CreateContractExecute(r ApiCreateContractRequest) (*GetContract200Response, *http.Response, error)

	/*
		CreateContracts Create multiple contracts

		Adds multiple contracts.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiCreateContractsRequest
	*/
	CreateContracts(ctx context.Context) ApiCreateContractsRequest

	// CreateContractsExecute executes the request
	//  @return BaseResponse
	CreateContractsExecute(r ApiCreateContractsRequest) (*BaseResponse, *http.Response, error)

	/*
		DeleteContract Delete a contract

		Deletes a contract and all its versions.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param contract
		@return ApiDeleteContractRequest
	*/
	DeleteContract(ctx context.Context, contract string) ApiDeleteContractRequest

	// DeleteContractExecute executes the request
	//  @return BaseResponse
	DeleteContractExecute(r ApiDeleteContractRequest) (*BaseResponse, *http.Response, error)

	/*
		DeleteContractVersion Delete a contract version

		Deletes a specific contract version.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param contract
		@param version Contract Version.
		@return ApiDeleteContractVersionRequest
	*/
	DeleteContractVersion(ctx context.Context, contract string, version string) ApiDeleteContractVersionRequest

	// DeleteContractVersionExecute executes the request
	//  @return BaseResponse
	DeleteContractVersionExecute(r ApiDeleteContractVersionRequest) (*BaseResponse, *http.Response, error)

	/*
		DeployContract Deploy a contract

		Returns a transaction to deploy the given contract to the blockchain.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param contract
		@return ApiDeployContractRequest
	*/
	DeployContract(ctx context.Context, contract string) ApiDeployContractRequest

	// DeployContractExecute executes the request
	//  @return DeployContract200Response
	DeployContractExecute(r ApiDeployContractRequest) (*DeployContract200Response, *http.Response, error)

	/*
		DeployContractVersion Deploy a contract version

		Returns a transaction to deploy the given contract version to the blockchain.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param contract
		@param version Contract Version.
		@return ApiDeployContractVersionRequest
	*/
	DeployContractVersion(ctx context.Context, contract string, version string) ApiDeployContractVersionRequest

	// DeployContractVersionExecute executes the request
	//  @return DeployContract200Response
	DeployContractVersionExecute(r ApiDeployContractVersionRequest) (*DeployContract200Response, *http.Response, error)

	/*
		GetContract Get a contract

		Returns the given contract.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param contract
		@return ApiGetContractRequest
	*/
	GetContract(ctx context.Context, contract string) ApiGetContractRequest

	// GetContractExecute executes the request
	//  @return GetContract200Response
	GetContractExecute(r ApiGetContractRequest) (*GetContract200Response, *http.Response, error)

	/*
		GetContractVersion Get a contract version

		Returns a specific contract version.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param contract
		@param version Contract Version.
		@return ApiGetContractVersionRequest
	*/
	GetContractVersion(ctx context.Context, contract string, version string) ApiGetContractVersionRequest

	// GetContractVersionExecute executes the request
	//  @return GetContract200Response
	GetContractVersionExecute(r ApiGetContractVersionRequest) (*GetContract200Response, *http.Response, error)

	/*
		GetContractVersions Get all contract versions

		Returns all the versions of a contract.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param contract
		@return ApiGetContractVersionsRequest
	*/
	GetContractVersions(ctx context.Context, contract string) ApiGetContractVersionsRequest

	// GetContractVersionsExecute executes the request
	//  @return GetContractVersions200Response
	GetContractVersionsExecute(r ApiGetContractVersionsRequest) (*GetContractVersions200Response, *http.Response, error)

	/*
		GetEventMonitorStatus Get event monitor status

		Returns the event monitor status for a given address and contract.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param chain The blockchain chain label.
		@param addressOrLabel An address or the label of an address.
		@param contract
		@return ApiGetEventMonitorStatusRequest
	*/
	GetEventMonitorStatus(ctx context.Context, chain ChainName, addressOrLabel string, contract string) ApiGetEventMonitorStatusRequest

	// GetEventMonitorStatusExecute executes the request
	//  @return GetEventMonitorStatus200Response
	GetEventMonitorStatusExecute(r ApiGetEventMonitorStatusRequest) (*GetEventMonitorStatus200Response, *http.Response, error)

	/*
		GetEventTypeConversions Get event type conversions

		Returns the type conversion options for a given contract and event signature.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param contract
		@param version Contract Version.
		@param event Contract Event.
		@return ApiGetEventTypeConversionsRequest
	*/
	GetEventTypeConversions(ctx context.Context, contract string, version string, event string) ApiGetEventTypeConversionsRequest

	// GetEventTypeConversionsExecute executes the request
	//  @return GetEventTypeConversions200Response
	GetEventTypeConversionsExecute(r ApiGetEventTypeConversionsRequest) (*GetEventTypeConversions200Response, *http.Response, error)

	/*
		GetFunctionTypeConversions Get function type conversions

		Returns the type conversion options for a given contract and function signature.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param contract
		@param version Contract Version.
		@param method Contract function.
		@return ApiGetFunctionTypeConversionsRequest
	*/
	GetFunctionTypeConversions(ctx context.Context, contract string, version string, method string) ApiGetFunctionTypeConversionsRequest

	// GetFunctionTypeConversionsExecute executes the request
	//  @return GetFunctionTypeConversions200Response
	GetFunctionTypeConversionsExecute(r ApiGetFunctionTypeConversionsRequest) (*GetFunctionTypeConversions200Response, *http.Response, error)

	/*
		LinkAddressContract Link address and contract

		Links an address to a contract.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param chain The blockchain chain label.
		@param addressOrLabel An address or the label of an address.
		@return ApiLinkAddressContractRequest
	*/
	LinkAddressContract(ctx context.Context, chain ChainName, addressOrLabel string) ApiLinkAddressContractRequest

	// LinkAddressContractExecute executes the request
	//  @return SetAddress201Response
	LinkAddressContractExecute(r ApiLinkAddressContractRequest) (*SetAddress201Response, *http.Response, error)

	/*
		ListContractVersions List all contract versions

		Returns a list of the versions of a contract.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param contract
		@return ApiListContractVersionsRequest
	*/
	ListContractVersions(ctx context.Context, contract string) ApiListContractVersionsRequest

	// ListContractVersionsExecute executes the request
	//  @return ListContractVersions200Response
	ListContractVersionsExecute(r ApiListContractVersionsRequest) (*ListContractVersions200Response, *http.Response, error)

	/*
		ListContracts List contracts

		Returns a list of contracts.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiListContractsRequest
	*/
	ListContracts(ctx context.Context) ApiListContractsRequest

	// ListContractsExecute executes the request
	//  @return ListContracts200Response
	ListContractsExecute(r ApiListContractsRequest) (*ListContracts200Response, *http.Response, error)

	/*
		SetEventTypeConversions Set event type conversions

		Sets the type conversion options for a given contract and event signature.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param contract
		@param version Contract Version.
		@param event Contract Event.
		@return ApiSetEventTypeConversionsRequest
	*/
	SetEventTypeConversions(ctx context.Context, contract string, version string, event string) ApiSetEventTypeConversionsRequest

	// SetEventTypeConversionsExecute executes the request
	//  @return BaseResponse
	SetEventTypeConversionsExecute(r ApiSetEventTypeConversionsRequest) (*BaseResponse, *http.Response, error)

	/*
		SetFunctionTypeConversions Set function type conversions

		Sets the type conversion options for a given contract and function signature.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param contract
		@param version Contract Version.
		@param method Contract function.
		@return ApiSetFunctionTypeConversionsRequest
	*/
	SetFunctionTypeConversions(ctx context.Context, contract string, version string, method string) ApiSetFunctionTypeConversionsRequest

	// SetFunctionTypeConversionsExecute executes the request
	//  @return BaseResponse
	SetFunctionTypeConversionsExecute(r ApiSetFunctionTypeConversionsRequest) (*BaseResponse, *http.Response, error)

	/*
		UnlinkAddressContract Unlink address and contract

		Unlinks an address from a contract.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param chain The blockchain chain label.
		@param addressOrLabel An address or the label of an address.
		@param contract
		@return ApiUnlinkAddressContractRequest
	*/
	UnlinkAddressContract(ctx context.Context, chain ChainName, addressOrLabel string, contract string) ApiUnlinkAddressContractRequest

	// UnlinkAddressContractExecute executes the request
	//  @return SetAddress201Response
	UnlinkAddressContractExecute(r ApiUnlinkAddressContractRequest) (*SetAddress201Response, *http.Response, error)
}

// ContractsAPIService ContractsAPI service
type ContractsAPIService service

type ApiCallContractFunctionRequest struct {
	ctx            context.Context
	ApiService     ContractsAPI
	chain          ChainName
	addressOrLabel string
	contract       string
	method         string
	postMethodArgs *PostMethodArgs
}

func (r ApiCallContractFunctionRequest) PostMethodArgs(postMethodArgs PostMethodArgs) ApiCallContractFunctionRequest {
	r.postMethodArgs = &postMethodArgs
	return r
}

func (r ApiCallContractFunctionRequest) Execute() (*CallContractFunction200Response, *http.Response, error) {
	return r.ApiService.CallContractFunctionExecute(r)
}

/*
CallContractFunction Call a contract function

Builds a transaction to call the given contract function. Returns a transaction to be signed and signs and submits to the blockchain it if the `signAndSubmit` flag is enabled.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param chain The blockchain chain label.
	@param addressOrLabel An address or the label of an address.
	@param contract
	@param method Contract function.
	@return ApiCallContractFunctionRequest
*/
func (a *ContractsAPIService) CallContractFunction(ctx context.Context, chain ChainName, addressOrLabel string, contract string, method string) ApiCallContractFunctionRequest {
	return ApiCallContractFunctionRequest{
		ApiService:     a,
		ctx:            ctx,
		chain:          chain,
		addressOrLabel: addressOrLabel,
		contract:       contract,
		method:         method,
	}
}

// Execute executes the request
//
//	@return CallContractFunction200Response
func (a *ContractsAPIService) CallContractFunctionExecute(r ApiCallContractFunctionRequest) (*CallContractFunction200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CallContractFunction200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.CallContractFunction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain}/addresses/{address-or-label}/contracts/{contract}/methods/{method}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", url.PathEscape(parameterValueToString(r.chain, "chain")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"address-or-label"+"}", url.PathEscape(parameterValueToString(r.addressOrLabel, "addressOrLabel")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", url.PathEscape(parameterValueToString(r.contract, "contract")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"method"+"}", url.PathEscape(parameterValueToString(r.method, "method")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.addressOrLabel) < 1 {
		return localVarReturnValue, nil, reportError("addressOrLabel must have at least 1 elements")
	}
	if strlen(r.method) < 1 {
		return localVarReturnValue, nil, reportError("method must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postMethodArgs
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateContractRequest struct {
	ctx          context.Context
	ApiService   ContractsAPI
	contract     string
	baseContract *BaseContract
}

func (r ApiCreateContractRequest) BaseContract(baseContract BaseContract) ApiCreateContractRequest {
	r.baseContract = &baseContract
	return r
}

func (r ApiCreateContractRequest) Execute() (*GetContract200Response, *http.Response, error) {
	return r.ApiService.CreateContractExecute(r)
}

/*
CreateContract Create a contract

Adds a contract.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contract
	@return ApiCreateContractRequest
*/
func (a *ContractsAPIService) CreateContract(ctx context.Context, contract string) ApiCreateContractRequest {
	return ApiCreateContractRequest{
		ApiService: a,
		ctx:        ctx,
		contract:   contract,
	}
}

// Execute executes the request
//
//	@return GetContract200Response
func (a *ContractsAPIService) CreateContractExecute(r ApiCreateContractRequest) (*GetContract200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetContract200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.CreateContract")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contract}"
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", url.PathEscape(parameterValueToString(r.contract, "contract")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.baseContract
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateContractsRequest struct {
	ctx          context.Context
	ApiService   ContractsAPI
	baseContract *[]BaseContract
}

func (r ApiCreateContractsRequest) BaseContract(baseContract []BaseContract) ApiCreateContractsRequest {
	r.baseContract = &baseContract
	return r
}

func (r ApiCreateContractsRequest) Execute() (*BaseResponse, *http.Response, error) {
	return r.ApiService.CreateContractsExecute(r)
}

/*
CreateContracts Create multiple contracts

Adds multiple contracts.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateContractsRequest
*/
func (a *ContractsAPIService) CreateContracts(ctx context.Context) ApiCreateContractsRequest {
	return ApiCreateContractsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return BaseResponse
func (a *ContractsAPIService) CreateContractsExecute(r ApiCreateContractsRequest) (*BaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.CreateContracts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.baseContract
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteContractRequest struct {
	ctx        context.Context
	ApiService ContractsAPI
	contract   string
}

func (r ApiDeleteContractRequest) Execute() (*BaseResponse, *http.Response, error) {
	return r.ApiService.DeleteContractExecute(r)
}

/*
DeleteContract Delete a contract

Deletes a contract and all its versions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contract
	@return ApiDeleteContractRequest
*/
func (a *ContractsAPIService) DeleteContract(ctx context.Context, contract string) ApiDeleteContractRequest {
	return ApiDeleteContractRequest{
		ApiService: a,
		ctx:        ctx,
		contract:   contract,
	}
}

// Execute executes the request
//
//	@return BaseResponse
func (a *ContractsAPIService) DeleteContractExecute(r ApiDeleteContractRequest) (*BaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.DeleteContract")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contract}"
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", url.PathEscape(parameterValueToString(r.contract, "contract")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteContractVersionRequest struct {
	ctx        context.Context
	ApiService ContractsAPI
	contract   string
	version    string
}

func (r ApiDeleteContractVersionRequest) Execute() (*BaseResponse, *http.Response, error) {
	return r.ApiService.DeleteContractVersionExecute(r)
}

/*
DeleteContractVersion Delete a contract version

Deletes a specific contract version.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contract
	@param version Contract Version.
	@return ApiDeleteContractVersionRequest
*/
func (a *ContractsAPIService) DeleteContractVersion(ctx context.Context, contract string, version string) ApiDeleteContractVersionRequest {
	return ApiDeleteContractVersionRequest{
		ApiService: a,
		ctx:        ctx,
		contract:   contract,
		version:    version,
	}
}

// Execute executes the request
//
//	@return BaseResponse
func (a *ContractsAPIService) DeleteContractVersionExecute(r ApiDeleteContractVersionRequest) (*BaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.DeleteContractVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contract}/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", url.PathEscape(parameterValueToString(r.contract, "contract")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.version) < 1 {
		return localVarReturnValue, nil, reportError("version must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeployContractRequest struct {
	ctx            context.Context
	ApiService     ContractsAPI
	contract       string
	postMethodArgs *PostMethodArgs
}

func (r ApiDeployContractRequest) PostMethodArgs(postMethodArgs PostMethodArgs) ApiDeployContractRequest {
	r.postMethodArgs = &postMethodArgs
	return r
}

func (r ApiDeployContractRequest) Execute() (*DeployContract200Response, *http.Response, error) {
	return r.ApiService.DeployContractExecute(r)
}

/*
DeployContract Deploy a contract

Returns a transaction to deploy the given contract to the blockchain.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contract
	@return ApiDeployContractRequest
*/
func (a *ContractsAPIService) DeployContract(ctx context.Context, contract string) ApiDeployContractRequest {
	return ApiDeployContractRequest{
		ApiService: a,
		ctx:        ctx,
		contract:   contract,
	}
}

// Execute executes the request
//
//	@return DeployContract200Response
func (a *ContractsAPIService) DeployContractExecute(r ApiDeployContractRequest) (*DeployContract200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeployContract200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.DeployContract")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contract}/deploy"
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", url.PathEscape(parameterValueToString(r.contract, "contract")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postMethodArgs
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeployContractVersionRequest struct {
	ctx            context.Context
	ApiService     ContractsAPI
	contract       string
	version        string
	postMethodArgs *PostMethodArgs
}

func (r ApiDeployContractVersionRequest) PostMethodArgs(postMethodArgs PostMethodArgs) ApiDeployContractVersionRequest {
	r.postMethodArgs = &postMethodArgs
	return r
}

func (r ApiDeployContractVersionRequest) Execute() (*DeployContract200Response, *http.Response, error) {
	return r.ApiService.DeployContractVersionExecute(r)
}

/*
DeployContractVersion Deploy a contract version

Returns a transaction to deploy the given contract version to the blockchain.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contract
	@param version Contract Version.
	@return ApiDeployContractVersionRequest
*/
func (a *ContractsAPIService) DeployContractVersion(ctx context.Context, contract string, version string) ApiDeployContractVersionRequest {
	return ApiDeployContractVersionRequest{
		ApiService: a,
		ctx:        ctx,
		contract:   contract,
		version:    version,
	}
}

// Execute executes the request
//
//	@return DeployContract200Response
func (a *ContractsAPIService) DeployContractVersionExecute(r ApiDeployContractVersionRequest) (*DeployContract200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DeployContract200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.DeployContractVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contract}/{version}/deploy"
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", url.PathEscape(parameterValueToString(r.contract, "contract")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.version) < 1 {
		return localVarReturnValue, nil, reportError("version must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.postMethodArgs
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractRequest struct {
	ctx        context.Context
	ApiService ContractsAPI
	contract   string
}

func (r ApiGetContractRequest) Execute() (*GetContract200Response, *http.Response, error) {
	return r.ApiService.GetContractExecute(r)
}

/*
GetContract Get a contract

Returns the given contract.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contract
	@return ApiGetContractRequest
*/
func (a *ContractsAPIService) GetContract(ctx context.Context, contract string) ApiGetContractRequest {
	return ApiGetContractRequest{
		ApiService: a,
		ctx:        ctx,
		contract:   contract,
	}
}

// Execute executes the request
//
//	@return GetContract200Response
func (a *ContractsAPIService) GetContractExecute(r ApiGetContractRequest) (*GetContract200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetContract200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetContract")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contract}"
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", url.PathEscape(parameterValueToString(r.contract, "contract")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractVersionRequest struct {
	ctx        context.Context
	ApiService ContractsAPI
	contract   string
	version    string
}

func (r ApiGetContractVersionRequest) Execute() (*GetContract200Response, *http.Response, error) {
	return r.ApiService.GetContractVersionExecute(r)
}

/*
GetContractVersion Get a contract version

Returns a specific contract version.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contract
	@param version Contract Version.
	@return ApiGetContractVersionRequest
*/
func (a *ContractsAPIService) GetContractVersion(ctx context.Context, contract string, version string) ApiGetContractVersionRequest {
	return ApiGetContractVersionRequest{
		ApiService: a,
		ctx:        ctx,
		contract:   contract,
		version:    version,
	}
}

// Execute executes the request
//
//	@return GetContract200Response
func (a *ContractsAPIService) GetContractVersionExecute(r ApiGetContractVersionRequest) (*GetContract200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetContract200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetContractVersion")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contract}/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", url.PathEscape(parameterValueToString(r.contract, "contract")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.version) < 1 {
		return localVarReturnValue, nil, reportError("version must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetContractVersionsRequest struct {
	ctx        context.Context
	ApiService ContractsAPI
	contract   string
}

func (r ApiGetContractVersionsRequest) Execute() (*GetContractVersions200Response, *http.Response, error) {
	return r.ApiService.GetContractVersionsExecute(r)
}

/*
GetContractVersions Get all contract versions

Returns all the versions of a contract.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contract
	@return ApiGetContractVersionsRequest
*/
func (a *ContractsAPIService) GetContractVersions(ctx context.Context, contract string) ApiGetContractVersionsRequest {
	return ApiGetContractVersionsRequest{
		ApiService: a,
		ctx:        ctx,
		contract:   contract,
	}
}

// Execute executes the request
//
//	@return GetContractVersions200Response
func (a *ContractsAPIService) GetContractVersionsExecute(r ApiGetContractVersionsRequest) (*GetContractVersions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetContractVersions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetContractVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contract}/all"
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", url.PathEscape(parameterValueToString(r.contract, "contract")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventMonitorStatusRequest struct {
	ctx            context.Context
	ApiService     ContractsAPI
	chain          ChainName
	addressOrLabel string
	contract       string
}

func (r ApiGetEventMonitorStatusRequest) Execute() (*GetEventMonitorStatus200Response, *http.Response, error) {
	return r.ApiService.GetEventMonitorStatusExecute(r)
}

/*
GetEventMonitorStatus Get event monitor status

Returns the event monitor status for a given address and contract.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param chain The blockchain chain label.
	@param addressOrLabel An address or the label of an address.
	@param contract
	@return ApiGetEventMonitorStatusRequest
*/
func (a *ContractsAPIService) GetEventMonitorStatus(ctx context.Context, chain ChainName, addressOrLabel string, contract string) ApiGetEventMonitorStatusRequest {
	return ApiGetEventMonitorStatusRequest{
		ApiService:     a,
		ctx:            ctx,
		chain:          chain,
		addressOrLabel: addressOrLabel,
		contract:       contract,
	}
}

// Execute executes the request
//
//	@return GetEventMonitorStatus200Response
func (a *ContractsAPIService) GetEventMonitorStatusExecute(r ApiGetEventMonitorStatusRequest) (*GetEventMonitorStatus200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEventMonitorStatus200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetEventMonitorStatus")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain}/addresses/{address-or-label}/contracts/{contract}/status"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", url.PathEscape(parameterValueToString(r.chain, "chain")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"address-or-label"+"}", url.PathEscape(parameterValueToString(r.addressOrLabel, "addressOrLabel")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", url.PathEscape(parameterValueToString(r.contract, "contract")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.addressOrLabel) < 1 {
		return localVarReturnValue, nil, reportError("addressOrLabel must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventTypeConversionsRequest struct {
	ctx        context.Context
	ApiService ContractsAPI
	contract   string
	version    string
	event      string
}

func (r ApiGetEventTypeConversionsRequest) Execute() (*GetEventTypeConversions200Response, *http.Response, error) {
	return r.ApiService.GetEventTypeConversionsExecute(r)
}

/*
GetEventTypeConversions Get event type conversions

Returns the type conversion options for a given contract and event signature.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contract
	@param version Contract Version.
	@param event Contract Event.
	@return ApiGetEventTypeConversionsRequest
*/
func (a *ContractsAPIService) GetEventTypeConversions(ctx context.Context, contract string, version string, event string) ApiGetEventTypeConversionsRequest {
	return ApiGetEventTypeConversionsRequest{
		ApiService: a,
		ctx:        ctx,
		contract:   contract,
		version:    version,
		event:      event,
	}
}

// Execute executes the request
//
//	@return GetEventTypeConversions200Response
func (a *ContractsAPIService) GetEventTypeConversionsExecute(r ApiGetEventTypeConversionsRequest) (*GetEventTypeConversions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetEventTypeConversions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetEventTypeConversions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contract}/{version}/events/{event}"
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", url.PathEscape(parameterValueToString(r.contract, "contract")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event"+"}", url.PathEscape(parameterValueToString(r.event, "event")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.version) < 1 {
		return localVarReturnValue, nil, reportError("version must have at least 1 elements")
	}
	if strlen(r.event) < 1 {
		return localVarReturnValue, nil, reportError("event must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetFunctionTypeConversionsRequest struct {
	ctx        context.Context
	ApiService ContractsAPI
	contract   string
	version    string
	method     string
}

func (r ApiGetFunctionTypeConversionsRequest) Execute() (*GetFunctionTypeConversions200Response, *http.Response, error) {
	return r.ApiService.GetFunctionTypeConversionsExecute(r)
}

/*
GetFunctionTypeConversions Get function type conversions

Returns the type conversion options for a given contract and function signature.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contract
	@param version Contract Version.
	@param method Contract function.
	@return ApiGetFunctionTypeConversionsRequest
*/
func (a *ContractsAPIService) GetFunctionTypeConversions(ctx context.Context, contract string, version string, method string) ApiGetFunctionTypeConversionsRequest {
	return ApiGetFunctionTypeConversionsRequest{
		ApiService: a,
		ctx:        ctx,
		contract:   contract,
		version:    version,
		method:     method,
	}
}

// Execute executes the request
//
//	@return GetFunctionTypeConversions200Response
func (a *ContractsAPIService) GetFunctionTypeConversionsExecute(r ApiGetFunctionTypeConversionsRequest) (*GetFunctionTypeConversions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetFunctionTypeConversions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.GetFunctionTypeConversions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contract}/{version}/methods/{method}"
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", url.PathEscape(parameterValueToString(r.contract, "contract")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"method"+"}", url.PathEscape(parameterValueToString(r.method, "method")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.version) < 1 {
		return localVarReturnValue, nil, reportError("version must have at least 1 elements")
	}
	if strlen(r.method) < 1 {
		return localVarReturnValue, nil, reportError("method must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLinkAddressContractRequest struct {
	ctx                        context.Context
	ApiService                 ContractsAPI
	chain                      ChainName
	addressOrLabel             string
	linkAddressContractRequest *LinkAddressContractRequest
}

func (r ApiLinkAddressContractRequest) LinkAddressContractRequest(linkAddressContractRequest LinkAddressContractRequest) ApiLinkAddressContractRequest {
	r.linkAddressContractRequest = &linkAddressContractRequest
	return r
}

func (r ApiLinkAddressContractRequest) Execute() (*SetAddress201Response, *http.Response, error) {
	return r.ApiService.LinkAddressContractExecute(r)
}

/*
LinkAddressContract Link address and contract

Links an address to a contract.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param chain The blockchain chain label.
	@param addressOrLabel An address or the label of an address.
	@return ApiLinkAddressContractRequest
*/
func (a *ContractsAPIService) LinkAddressContract(ctx context.Context, chain ChainName, addressOrLabel string) ApiLinkAddressContractRequest {
	return ApiLinkAddressContractRequest{
		ApiService:     a,
		ctx:            ctx,
		chain:          chain,
		addressOrLabel: addressOrLabel,
	}
}

// Execute executes the request
//
//	@return SetAddress201Response
func (a *ContractsAPIService) LinkAddressContractExecute(r ApiLinkAddressContractRequest) (*SetAddress201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SetAddress201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.LinkAddressContract")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain}/addresses/{address-or-label}/contracts"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", url.PathEscape(parameterValueToString(r.chain, "chain")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"address-or-label"+"}", url.PathEscape(parameterValueToString(r.addressOrLabel, "addressOrLabel")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.addressOrLabel) < 1 {
		return localVarReturnValue, nil, reportError("addressOrLabel must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.linkAddressContractRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListContractVersionsRequest struct {
	ctx        context.Context
	ApiService ContractsAPI
	contract   string
}

func (r ApiListContractVersionsRequest) Execute() (*ListContractVersions200Response, *http.Response, error) {
	return r.ApiService.ListContractVersionsExecute(r)
}

/*
ListContractVersions List all contract versions

Returns a list of the versions of a contract.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contract
	@return ApiListContractVersionsRequest
*/
func (a *ContractsAPIService) ListContractVersions(ctx context.Context, contract string) ApiListContractVersionsRequest {
	return ApiListContractVersionsRequest{
		ApiService: a,
		ctx:        ctx,
		contract:   contract,
	}
}

// Execute executes the request
//
//	@return ListContractVersions200Response
func (a *ContractsAPIService) ListContractVersionsExecute(r ApiListContractVersionsRequest) (*ListContractVersions200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListContractVersions200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.ListContractVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contract}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", url.PathEscape(parameterValueToString(r.contract, "contract")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListContractsRequest struct {
	ctx        context.Context
	ApiService ContractsAPI
}

func (r ApiListContractsRequest) Execute() (*ListContracts200Response, *http.Response, error) {
	return r.ApiService.ListContractsExecute(r)
}

/*
ListContracts List contracts

Returns a list of contracts.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiListContractsRequest
*/
func (a *ContractsAPIService) ListContracts(ctx context.Context) ApiListContractsRequest {
	return ApiListContractsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ListContracts200Response
func (a *ContractsAPIService) ListContractsExecute(r ApiListContractsRequest) (*ListContracts200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListContracts200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.ListContracts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetEventTypeConversionsRequest struct {
	ctx                  context.Context
	ApiService           ContractsAPI
	contract             string
	version              string
	event                string
	contractEventOptions *ContractEventOptions
}

func (r ApiSetEventTypeConversionsRequest) ContractEventOptions(contractEventOptions ContractEventOptions) ApiSetEventTypeConversionsRequest {
	r.contractEventOptions = &contractEventOptions
	return r
}

func (r ApiSetEventTypeConversionsRequest) Execute() (*BaseResponse, *http.Response, error) {
	return r.ApiService.SetEventTypeConversionsExecute(r)
}

/*
SetEventTypeConversions Set event type conversions

Sets the type conversion options for a given contract and event signature.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contract
	@param version Contract Version.
	@param event Contract Event.
	@return ApiSetEventTypeConversionsRequest
*/
func (a *ContractsAPIService) SetEventTypeConversions(ctx context.Context, contract string, version string, event string) ApiSetEventTypeConversionsRequest {
	return ApiSetEventTypeConversionsRequest{
		ApiService: a,
		ctx:        ctx,
		contract:   contract,
		version:    version,
		event:      event,
	}
}

// Execute executes the request
//
//	@return BaseResponse
func (a *ContractsAPIService) SetEventTypeConversionsExecute(r ApiSetEventTypeConversionsRequest) (*BaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.SetEventTypeConversions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contract}/{version}/events/{event}"
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", url.PathEscape(parameterValueToString(r.contract, "contract")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"event"+"}", url.PathEscape(parameterValueToString(r.event, "event")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.version) < 1 {
		return localVarReturnValue, nil, reportError("version must have at least 1 elements")
	}
	if strlen(r.event) < 1 {
		return localVarReturnValue, nil, reportError("event must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contractEventOptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetFunctionTypeConversionsRequest struct {
	ctx                   context.Context
	ApiService            ContractsAPI
	contract              string
	version               string
	method                string
	contractMethodOptions *ContractMethodOptions
}

func (r ApiSetFunctionTypeConversionsRequest) ContractMethodOptions(contractMethodOptions ContractMethodOptions) ApiSetFunctionTypeConversionsRequest {
	r.contractMethodOptions = &contractMethodOptions
	return r
}

func (r ApiSetFunctionTypeConversionsRequest) Execute() (*BaseResponse, *http.Response, error) {
	return r.ApiService.SetFunctionTypeConversionsExecute(r)
}

/*
SetFunctionTypeConversions Set function type conversions

Sets the type conversion options for a given contract and function signature.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param contract
	@param version Contract Version.
	@param method Contract function.
	@return ApiSetFunctionTypeConversionsRequest
*/
func (a *ContractsAPIService) SetFunctionTypeConversions(ctx context.Context, contract string, version string, method string) ApiSetFunctionTypeConversionsRequest {
	return ApiSetFunctionTypeConversionsRequest{
		ApiService: a,
		ctx:        ctx,
		contract:   contract,
		version:    version,
		method:     method,
	}
}

// Execute executes the request
//
//	@return BaseResponse
func (a *ContractsAPIService) SetFunctionTypeConversionsExecute(r ApiSetFunctionTypeConversionsRequest) (*BaseResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BaseResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.SetFunctionTypeConversions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/contracts/{contract}/{version}/methods/{method}"
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", url.PathEscape(parameterValueToString(r.contract, "contract")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"method"+"}", url.PathEscape(parameterValueToString(r.method, "method")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.version) < 1 {
		return localVarReturnValue, nil, reportError("version must have at least 1 elements")
	}
	if strlen(r.method) < 1 {
		return localVarReturnValue, nil, reportError("method must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.contractMethodOptions
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnlinkAddressContractRequest struct {
	ctx            context.Context
	ApiService     ContractsAPI
	chain          ChainName
	addressOrLabel string
	contract       string
}

func (r ApiUnlinkAddressContractRequest) Execute() (*SetAddress201Response, *http.Response, error) {
	return r.ApiService.UnlinkAddressContractExecute(r)
}

/*
UnlinkAddressContract Unlink address and contract

Unlinks an address from a contract.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param chain The blockchain chain label.
	@param addressOrLabel An address or the label of an address.
	@param contract
	@return ApiUnlinkAddressContractRequest
*/
func (a *ContractsAPIService) UnlinkAddressContract(ctx context.Context, chain ChainName, addressOrLabel string, contract string) ApiUnlinkAddressContractRequest {
	return ApiUnlinkAddressContractRequest{
		ApiService:     a,
		ctx:            ctx,
		chain:          chain,
		addressOrLabel: addressOrLabel,
		contract:       contract,
	}
}

// Execute executes the request
//
//	@return SetAddress201Response
func (a *ContractsAPIService) UnlinkAddressContractExecute(r ApiUnlinkAddressContractRequest) (*SetAddress201Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SetAddress201Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractsAPIService.UnlinkAddressContract")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/chains/{chain}/addresses/{address-or-label}/contracts/{contract}"
	localVarPath = strings.Replace(localVarPath, "{"+"chain"+"}", url.PathEscape(parameterValueToString(r.chain, "chain")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"address-or-label"+"}", url.PathEscape(parameterValueToString(r.addressOrLabel, "addressOrLabel")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contract"+"}", url.PathEscape(parameterValueToString(r.contract, "contract")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.addressOrLabel) < 1 {
		return localVarReturnValue, nil, reportError("addressOrLabel must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode >= 400 && localVarHTTPResponse.StatusCode < 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode >= 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
